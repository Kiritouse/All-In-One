
# 超码,主码,主属性,候选码非主属性

PS:    元组：可以理解为一张表中的每条记录，也就是每一行

超码：能够唯一标识一条记录的属性或属性集

标识性：一个数据表的所有记录都具有不同的超键
非空性：不能为空
候选码：能够唯一标识一条记录的最小属性集(不含多余属性)

标识性：一个数据表的所有记录都具有不同的候选键
最小性：候选键的任何子集都不能唯一标识一个记录
非空性：不能为空
主码：某个能够唯一标识一条记录的最小属性集（候选码中的“人选之子”）

唯一性：一个数据表只能有一个主键
标识性：一个数据表的所有记录都具有不同的主键取值
非空性：不能为空
超码、候选码和主码总结：

共同点：惟一标识一个元组

 区别：超码中可能有无关的属性，而主码和候选码中属性都是必要的属性；

主码是候选码中的一个”人选之子“（数据库设计者所选）

主属性：包含在候选码中的属性

非主属性：不包含在候选码中的属性称为非主属性，相对于主属性来定义的。

- 主属性
> 能够唯一标识一条记录的属性或者属性组
- 候选码
> 候选码是能够唯一标识一条记录的属性或属性组。如果一个关系中的某一属性组的值能够唯一地标识一个元组，那么这个属性组就是候选码。举个例子，如果我们有一个学生表格，其中包含学号、姓名、性别等属性，那么学号和姓名都可以作为候选码，因为它们能够唯一标识每个学生。
- 主码
> 主码是从候选码中人为选择的一个属性或属性组，用来唯一标识一条记录。
> ![](Pasted%20image%2020240525143310.png)
 > 不难看出,S,J可以决定P,J,P可以决定S,因为主属性是所有可以唯一标识一条记录的属性组,所以三个均是主属性,而候选码是最小的主属性

主属性中是存在数据冗余的,候选码是最小的主属性属性组,如果少了一个都不能唯一地标识一条记录

# 函数依赖
## 完全函数依赖
> 如果我们有一个关系模式S (Sno, Sname, Cno, Grade)，那么成绩Grade完全依赖于学号Sno和课程号Cno。如果只知道其中一部分信息，比如只知道学号Sno或者课程号Cno，是无法确定成绩Grade的。

## 部分函数依赖
如果我们想知道某位学生的姓名Sname，只需要知道他的学号Sno即可，而不需要知道其他属性。

## 传递函数依赖
如果我们有一个关系模式S (Sno, Sdept, Mname)，知道学号Sno可以确定所在系的系主任姓名Mname。这里学号Sno和系主任姓名Mname之间不存在直接的函数依赖，但是通过系名称Sdept作为桥梁，我们可以将它们联系起来
# 2NF
> 每一个非主属性都完全依赖于所有的候选码,不能出现只依赖于部分候选码,这样的情况就属于2NF
2NF就是消除非主属性对主属性的部分函数依赖，全部改成完全函数依赖
![](Pasted%20image%2020240515211840.png)

> **2NF就是消除非主属性对主属性的部分函数依赖，全部改成完全函数依赖**
> 
![](Pasted%20image%2020240515211822.png)

![](Pasted%20image%2020240515211920.png)

> 拆的方法：谁跟你好，复制自己带走
> ![](Pasted%20image%2020240515211936.png)

[什么是第一，第二，第三范式\_第一范式第二范式第三范式的定义-CSDN博客](https://blog.csdn.net/xidianliuy/article/details/51566576)

# 3NF
在第二范式的基础上，数据表中如果不存在非关键字段对任一候选关键字段的传递函数依赖则符合第三范式

出现传递依赖A->B->C，即主键A可以确定出某一非关键字段B，而B又可以确定出C，这意味着C依赖于一个非关键字段B。因此第三范式又可描述为：*表中不存在可以确定其他非关键字的非关键字段*

拆解方法:
 > 表：(学号, 姓名, 年龄, 所在学院, 学院地点, 学院电话)

该表中候选字段只有“学号”，于是“学号”做主键。由于主键是单一属性，所以不存在非主属性对主键的部分函数依赖的问题，所以必然满足第二范式。但是存在如下传递依赖

(学号) → (所在学院) → (学院地点, 学院电话)

学院地点和学院电话传递依赖于学号，而学院地点和学院电话都是非关键字段，即表中出现了“某一非关键字段可以确定出其它非关键字段”的情况，于是违反了第三范式。
# BCNF
BCNF要求**主属性**(注意不是候选码)里也不能存在函数传递依赖

# 用通俗的语言来说
对于Table(A,B,C,D,E)  ,A,B是主属性集合,为候选键位
如果(A,B)->C  ,是完全函数依赖
如果存在B->C,那么这里就==不满足第二范式== ,因为能将B->C单独拆开

如果存在  C->D,那么就==不满足第三范式==,因为这样能将C->D单独拆开成另一个表
![](Pasted%20image%2020240525141435.png)

# 数据依赖的公理系统
## 逻辑蕴含
> 其实就是将一组成立的函数依赖给抽象出来成一个名字,例如F逻辑蕴涵X->Y,即函数依赖X->Y成立

## 阿姆斯特朗公理系统
- 求给定表(关系模式)的码
- 从一组函数依赖求得其中所有的函数依赖
### 三大定律
    1. 自反律:U是属性总体,若Y<X<U,则对于一组函数依赖F
	2. 增广律,X->Y成立,Z<U,则XZ->YZ也成立
	3. 传递律,X->Y Y->Z X->Z成立
### 三条推理规则
	1. 合并规则
		由X->Y,X->Z,由X->YZ
	2.伪传递规则
			由X->Y,WY->Z,有XW->Z
	3.分解规则
			由X->Y及,Z<Y,有X->Z
	
## 闭包
### 函数依赖集合的闭包
写出F中的所有函数依赖(写了的+没写的)
### 属性关于F的闭包
由某个属性A能推导出来的所有属性
![](Pasted%20image%2020240528140045.png)

明面上写的+推到出来的,所有函数依赖情况
标准写法
![](Pasted%20image%2020240528140406.png)
	以某个属性的闭包,就把这个属性省略
## 例题
![](Pasted%20image%2020240528142511.png)
![](Pasted%20image%2020240528142604.png)
> 求AB的闭包,实际上就是**一股脑写出所有AB能推出的可能属性**
> 1. X0 =AB
> 2. 找B,看**A,B,AB**能**直接**(别考虑传递)推出什么,求存入B中,AB->C,B->D则B=CD  ,
> 3. 看是否满足退出条件(1.当前并上后是否和上一个X相等,2.当前并上后是否等于全集)
> 4. 不满足继续执行操作,AB->C,B->D,C->E,EC->B

> 不难看出,AB的闭包能推出所有的表头,这个AB实际上就是**候选码**

## 函数依赖集合相等的判断
> 看两个函数依赖集的闭包是否一致

## 最小依赖集Fmin和F和F+
> 区别是这样的
>  F+>F>Fmin
>  F+是包含写了的和没写的,但实际上F+和F是等价的
>  Fmin是去掉了哪些能推导出来的,留下了不能由其他推到来的

## 最小函数依赖集合的作用

## 找最下函数依赖集的方法
> 核心是只要单一属性
![](Pasted%20image%2020240528145857.png)
1. 拆,如果由A->BC,那么就拆成A->B,A->C(**右**)
2. 去掉可以由传递得出的冗余,方法就是先**删掉**这个函数依赖,如果删掉后还能通过传递变回原来的,则这个就可以去掉(**中**),比如去掉,AB->C, 就看AB在**剩下**的属性集合里面的**闭包**是如何的,有没有**C**
3. 如果由AB->C,A->C,那么就留下简单的,A->C (**左边**)  (这里是要右边相同的情况),**看左端的子集能不能推出右端**
即先处理右边,在处理中间.最后处理左边

## 快速找候选码
> 如果一个属性只在右边出现,而不在左边出现,那么一定不是候选码,因为它一直被人决定,从不决定别人
> 如果一个属性在两端都出现过,那么这个属性有可能是,也有可能不是,我们放到一边**备用**
> 如果一个属性只在左边出现,那么这个属性一定是码中的一个属性,那么求这个属性的闭包,看能不能推出全集,如果能,那么这个一定是候选码,如果不能推出,那么将备用的属性和这个属性并到一起求闭包,看能不能求到全集

## 习题
### 1.找Fmin,候选键,规范成3NF
![](Pasted%20image%2020240528153020.png)
> 3.将这个表变成3NF

> 问题1分析:找Fmin
> 	首先这个F不是单键,所以我们要给他们变成单个
> 	 **右边**:ADG->BC  可以变成ADG->B,ADG->C
> 	 然后剩下BG->C,BD->E,DG->C,ADG->B,ADG->C,AG->B,B->D
> 	 观察可以看到ADG->B与AG->B有重合和冲突,所以去除**繁杂**,留下AG->B
> 	 同理可以去掉ADG->C,因为有DG->C
> 	 剩下G=F-(BG->C)=BD->E,DG->C,AG->B,B->D 
> 	 **中间**: 先去掉BG->C,看下能否从剩下的推出BG->C
	   > X0=BG(G+)
	    > X1=X0(BG)+D=BDG
	   > X2=X1(BDG)+ECD=BCDEG
	   > X3=X2(BCDEG)+....(找不到A,因为只在左端出现了) 所以停止,因为X3=X2
	   所以(BG)+ = BCDEG 还能推出C,代表**BG->C多余**
> 	 同理最后剩下~~**F=BD->E,DG->C,AG->B,B->D**~~     ~~F=B->E,DG->C,AG->N,B->D~~
> 	 (~~**这里有可能会被认为B->D ,BD->E,得到B->E,但实际上这个是不行的因为要得到B->E,应该是B->D,D->E,B->E这种情况,因为不存在D->E所以不可以化简**)~~
> 	 (**这里要划掉BD->E,因为假设删除属性B,D的闭包中没有B,因此B不是冗余,假设删除属性D,B的闭包有D,所以D是冗余属性,所以删掉D,留下B->E**)
> 	 **左边**:没有左边子集能单独推出右边
> 问题2分析:找候选键
> 		只在左边出现的属性:A,G(一定是码中的属性)
> 		只在右边出现的属性:C,E,(一定不是码中的属性)
> 		两边都出现的属性:B,D(后备,既可以做候选码也可以不做候选码)
> 		 候选键:A,G
> 		 **先不考虑B,D**
> 		 X0=AG
> 		 X1=X0(AG)+B=AGB
> 		 X2=AGB+D=ABDG
> 		 X3=ABDG+E=ABCDEG=U 所以**不需要B,D**了
> 问题3分析: 将这个表U拆开,3NF要满足不能出现非关键键的传递依赖
> 	U1=AGB(F=AG->B)
> 	 U2=BDE(F=BD->E,B->D)
> 	 U3=CDG(DG->C)
> 	 
> 		 

# 数据依赖的公理系统的应用


## 函数集依赖闭包计算
## 属性的闭包计算
> 所谓的关于某个属性的闭包,实际上就是列出某个属性能推出的所有属性

### 判定超码
> 根据给出的函数依赖,对于要判定的Key,求出这个Key的闭包
> 如果这个Key的闭包能得到所有的属性集那么就说明这个Key是超码
### 判定候选码

### 判定函数依赖集合是否属于函数依赖闭包


## 分解后函数依赖的保持

## BCNF的判定 
### 分解后的BCNF的判定

## 求Fmin(函数依赖集合的正则覆盖)