预处理,就是在查询结果的时候,先将输入的数据中的一些信息用数组之类的数据结构存储起来
查询的时候就能直接在O(1)的情况下进行查询

# 差分
差的本质是能在O(1)的时间复杂度下能够对一段区间进行+和-一个数
那么在题目中该怎么用呢?
我自己的理解是,如果有以下含义,在一段区间[a,b]内,答案x满足,那么久可以用差分,对[a,b]的区间同时+1,那么后续查询的时候,就可以查询 i ==落在了几个区间==,就可以获得方案数
还有前缀和,还原数组的时候,==注意范围==,因为我们是预处理,也就是这个数组中包含了所有的数据范围,因此我们要从最小到最大全部前缀和出来

例子如下
[AcWing 4455. 出行计划 - AcWing](https://www.acwing.com/solution/content/120611/)
> 这道题的这个人写的题解写得很不错,我们查询的时候,因为用差分对符合条件的区间进行了统计,如果有一个数,x,落在了符合条件的两个区间之间,那么自然会因为差分的+1而递增,即我们只需要查询落在了哪几个区间,即可获取方案数

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 2e5+3;
int diff[N] = {};
int main(){
    int n,m,k;
    cin>>n>>m>>k;
    for(int i = 0;i<n;i++){
        int t,c;
        cin>>t>>c;
        diff[max(1,t-k-c+1)]+=1;
        diff[max(1,t-k+1)]-=1;
    }
    for(int i = 1;i<=N;i++){
        diff[i]+=diff[i-1];
    }
    for(int i = 0;i<m;i++){
        int q;
        cin>>q;
        cout<<diff[q]<<endl;
    }
}
```
# 前缀和
前缀和sum[i]  = _sum_ 是[1,i]的和
用前缀和可以快速求得[l,r]之间的和是多少
ans = sum[r]-sum[l-1]  ,记得从下标1开始前缀和
[5017. 垦田计划 - AcWing题库](https://www.acwing.com/problem/content/5020/)
> 这道题,先不管这些复杂的,先从简单的一块田开始入手,根据题意简单模拟一遍(先不管限制条件),找找规律
> 考虑一块田,其时间为5, 花费为1 缩写为(5,1)
> 减少1天需要花费1,减少2天需要花费2,减少3天需要花费3,==看着有点像前缀和==
> 故,我们把前缀和之前的形态表示出来
> 1 2 3 4 5
>  1 1 1 1 1
> 比如sum[3]就是3
> 又细看,又有点像差分,即[1,5]+1
> 感觉可以先差分,再前缀和,于是,我们再增大一下问题规模看看情况
>   考虑第二块天,其时间为3,花费为2,缩写为(3,2);

	1 2 3 4 5
	1 1 1 1 1
	2 2 2
不难发现,由第5天减到第3天,直接是对sum[5]-sum[3] = 2,即前缀和查询
如果减到第3天了,再继续减,就得将第二块田加入进来
这样就可以用前缀和了
故做法就呼之欲出了,先差分处理吗,再前缀和
> 个人感觉 CCF CSP第二题很喜欢考前缀和和差分


适合对区间进行处理
序列$a_1$, $a_2$, $a_3$, $a_4$, $a_5$,......$a_n$
# 前缀和: 
prefix[0] = 0;
prefix[1] = $a_1$;
prefix[2] = $a_1$+$a_2$;
prefix[3] = $a_1$+$a_2$+$a_3$;
..
==预处理:==
```c++
for(int i = 1;i<=n;i++){
	prefix[i] = prefix[i-1]+ a[1];
}
```
==还原原始数组==:$a_i$ = prefix[i]-prefix[i-1];
区间和


# 差分:
>差分是一种数据处理方式
>有些题目并没有明显的差分的形式
>但是在我们构造某些数组的时候,可以用差分来快速对构造的数组的某一区间进行批量修改
>再通过对差分数组进行前缀和,即可还原
diff[0] = 0;
diff[1] = $a_1$
diff[2] = $a_2$-$a_1$;
diff[3] = $a_3$-$a_2$;
...

==预处理==
```c++
for(int i = 1;i<=n;i++){
	diff[i] = a[i]-a[i-1];
}
```

==还原==: $a_i$ = diff[i]+a[i-1] **这里也相当于一个前缀和**

- **差分适用于对一个区间加上或者减去某个数**
diff[l]+=x,diff[r+1]-=x; 这两步操作对于[l,r]加上了一个数字x;
我们diff[l]+=x等价于对于[l,n]+x
diff[r+1]等价于对于[r,n]-x
- **也适用于对一个区间进行某些特征的统计**
[AcWing 5267. 合格数(前缀和 + 差分 + 线段树) - AcWing](https://www.acwing.com/solution/content/205907/)
此题就利用差分来处理==一段区间==内每个点被覆盖了多少次
再==还原==出原始数组,得到==某个点==被覆盖了多少次



## 例题1
[507. 积木大赛 - AcWing题库](https://www.acwing.com/problem/content/description/509/)

这道题我们首先要学会==转化问题==
题目是从0->目标高度,不如逆行思考,从目标高度->0

对目标高度构造差分数组
![](Pasted%20image%2020240826144427.png)
因此问题变成每次从 b1,b2,…,bn+1  注意这里多了一个bn+1,因此sum bi = 0
 中挑两个数，前一个减1，后一个加1，问最少操作多少次可以将所有数变成0


所有数为0代表bi的前缀和为0
并且bi为0

所有总的操作次数一定不能少于差分数组中的所有正数之和B

==这里就是贪心了==
贪心最难的就是证明是否有操作满足可以达到B




[AcWing 507. 积木大赛 - AcWing](https://www.acwing.com/solution/content/3256/)  还是查看题解好些

## 例题2
[5017. 垦田计划 - AcWing题库](https://www.acwing.com/problem/content/5020/)
这道题我已经用了好几种解法
详见如下链接
[二分算法](二分算法.md)
[优先队列&&从样例中看出端倪,解法](优先队列&&从样例中看出端倪,解法.md)
现在添加第三种解法,利用二分算法

> 分析:
> 首先抓住题目的本质
> 对于一段序列ti,如果要让ti减一,那么需要花费对应的ci
> 要求我们在资源m限制下,求得能让max(ti)能减少到多少
> 我们可以用一个数组来存储花费i天开垦所有田的花费
> 从简单开始,先考虑一个块田(5,1)
> 1 2 3 4 5
> 1 1  1  1  1
> 这块田对每天的贡献都为1,也就是说我们可以用差分加前缀和来做
> 前缀和求得前n天的田1的花费,例如由5缩短为3,那么求每天累积贡献
> 如果再添加一块田2(3,2)
> 那么差分对前3同时增加2,前缀和还原后再前缀和,即可求得两块田前n天的总花费贡献
> 如果一个区间l,r,那么sum[r]- sum[l-1]即可求得
```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 1e5+3;
ll b[N] = {};
ll n,m,k;
ll _max = 0;
void diff(int l,int r,int c){
	b[l]+=c;
	b[r+1]-=c;
}
bool check(ll mid){
		ll cost = b[_max]-b[mid-1];
		if(cost<=m)return true;
		else return false;
}
int main(){

	cin>>n>>m>>k;
	for(int i = 1;i<=n;i++){
		ll _t,_c;
		cin>>_t>>_c;
		_max = max(_max,_t);
		diff(1,_t,_c);
	}
	for(int i = 1;i<=_max;i++)b[i] += b[i-1];
	for(int i = 1;i<=_max;i++)b[i] += b[i-1];
	
	ll l=-1,r = _max+1;
	while(l+1!=r){
		ll mid = (l+r)>>1;
		if(check(mid))r = mid;
		else l =mid ;
	}
	cout<<max(r-1,k)<<endl;
	//这里返回r-1主要是
	/*
		1.考虑到我们构造的这个差分数组,是累计所有田对于第i天的花费的贡献
		例如 1 2 3 4 5
		(5,1)
		(3,2)
		这样第5天减到第3天就只有第一块田的花费做出了贡献,同时我们二分的天数
		比如,我们check(3)代表的是3 4 5的花费,是减到第二天的总花费,一共减了3天
		而减到第三天,只需要检查(4,5)的花费即可
		所以最后要r-1,这里建议查看我自己做的二分模板,就是isBlue那个
	*/
	return 0;
}
```