|                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |     |     |
| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --- | --- |
| ### Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |     |     |
| # 积[#](https://acm.xtu.edu.cn/exam/index.php/problem/exam_read/id/1586/exam_id/462#_1 "Permanent link")<br><br>## 题目描述[#](https://acm.xtu.edu.cn/exam/index.php/problem/exam_read/id/1586/exam_id/462#_2 "Permanent link")<br><br>n个整数，取k个，使得它们的积最大，求积的值。<br><br>比如4个整数−1,1,−2,−3，取3个的积的最大值为6。<br><br>## 输入格式[#](https://acm.xtu.edu.cn/exam/index.php/problem/exam_read/id/1586/exam_id/462#_3 "Permanent link")<br><br>第一行是一个整数T (1≤T≤100)，表示样例的个数。<br><br>每个样例第一行是两个整数n,k (1≤k≤n≤10^4)；第二行是n个整数，所有整数的绝对值不超过10^9<br><br>## 输出格式[#](https://acm.xtu.edu.cn/exam/index.php/problem/exam_read/id/1586/exam_id/462#_4 "Permanent link")<br><br>依次每行输出一个样例的结果，由于这个值很大，请将其对10^9+7取模。<br><br>## 样例输入[#](https://acm.xtu.edu.cn/exam/index.php/problem/exam_read/id/1586/exam_id/462#_5 "Permanent link")<br><br>2<br>4 3<br>-1 1 -2 -3<br>4 3<br>-1 -2 -3 -4<br><br>## 样例输出[#](https://acm.xtu.edu.cn/exam/index.php/problem/exam_read/id/1586/exam_id/462#_6 "Permanent link")<br><br>6<br>-6<br><br>## 提示[#](https://acm.xtu.edu.cn/exam/index.php/problem/exam_read/id/1586/exam_id/462#_7 "Permanent link")<br><br>巨大的输入数据，请使用`stdio.h`头文件和C风格的输入输出。 |     |     |
|                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |     |     |
|                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |     |     |
|                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |     |     |
> [[Greedy Algorithm(贪心算法)]]
> [[大数取模]]

思路分析:这道题其实就是一个贪心+大数取模防止爆long long的题,主要的思考难点在于贪心策略.
如果要取积最大,不难看出积一定与k是奇数还是偶数有关,这代表我们可以**分类讨论**,假设最后的最大的积为非负数,那么我们可以采取以下策略,首先按照数字从小到大进行排序,如果k为奇数,我们可以先取最大的数字,单独拿出来,剩下的k为偶数,对于剩下的数,我们每次都选择最大的两个(首尾相邻的两个乘积进行比较(这里是考虑到两个负数相乘的形式),每次都选择乘积比较大的加入到答案里),如果这种策略得出来的结果是负数,说明最大积一定为负数,那么我们就将原数组按照绝对值大小排序,取前k个进行计算.
为什么会考虑到这种算法?如何证明? 
1.因为k为奇数,  假设取最大非负数积,那么可分割为偶数个k-1 * 选的第k个数,   那么偶数个k-1的乘积的符号和第k个符号相同 , 如果要取最大, 那么第k个数一定要选择最大的,即最右边的,会出现如果选了最右边的反而导致变小的情况吗?假设第k个数为负数,前k-1的乘积为正数,那么此时就采用最大积为负数的策略了,所以不可能. 所以会出现第k个数为负数,但是前k-1的乘积为正数的情况吗?也不可能,因为我们排序了,如果出现了的话,第k个数一定是正数,综上所述,我们选择第k个数的话不会使得结果变坏,综上,那么如果采取这种策略得出来的结果是负数(不代表此处的积为最后的结果),与假设矛盾(说明第二要分类讨论),我们就应该采取说明最大积一定为负数,那么我们就采取最大积为负数的策略
2.为什么说采取第一种策略得出来的结果为负数不一定是最后的最大积为负数的情形下的正确的结果,因为不满足我们的假设.我们的贪心策略是针对最大积为正数的情况,如果满足最大积为正数,那么采取这种贪心策略的结果一定是正数,不然我们的策略就不对,(循环不变式)那么分析为什么会出现最大积为负数的情况.
- k为奇数,且k个数全部都是负数,那么这种情况下最大积一定为负数
- 采取贪心策略不得已选择了一正一负交界的,因为是**有序**数组,正常两两比较的时候是左边和右边比较,一定会选择乘积正数且大的一方,而如果出现有5个数,三个为负数,2个为正数,这样的选择就会导致这种策略选出来为负数,因为最后一定会选择一正一负交界
```c++
#include <bits/stdc++.h>
const int maxsize = 10005;
const int modnum = 1e9+7;
using namespace std;
typedef __int64 i64;
int main() {
	int t;
	scanf("%d", &t);
	while (t--) {
		int n, k;
		scanf("%d %d", &n, &k);
		int arr[maxsize] = {0};
		for (int i = 0; i < n; i++) {
			scanf("%d", &arr[i]);
		}
		sort(arr, arr + n);
		i64 ans = 1;
		//先正常选择
		int cntchoose = 0;
		int l = 0, r = n - 1;
		if (k & 1) { //k是奇数,提前选择一个
			ans *= arr[n - 1];
			ans%=modnum;
			cntchoose++;
			r--;
		}
		while (cntchoose < k) {
			i64 a = arr[l];
			i64 b = arr[l + 1];

			i64 c = arr[r];
			i64 d = arr[r - 1];

			i64 temp1 = a * b;
			
			i64 temp2 = c * d;
			if (temp1 > temp2) {
				temp1%=modnum;
				ans *= temp1;  
				ans%=modnum;
				l += 2;
			} else {
				temp2%=modnum;
				ans *= temp2;
				ans%=modnum;
				r-=2;
			}
			cntchoose += 2;
		}
		if (ans <= 0) { //处理负数的情况
			ans = 1;
			for (int i = 0; i < n; i++) {
				arr[i] = abs(arr[i]);
			}
			sort(arr, arr + n);
			for (int i = 0; i < k; i++) {
				ans *= arr[i];
				ans%=modnum;
			}
			ans %= modnum;
			ans = -ans;
			printf("%I64d\n",ans);
			continue;
		} else printf("%I64d\n", ans);
	}
}
```