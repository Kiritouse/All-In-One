#define CLOSE_TIE std::ios::sync_with_stdio(false),cin.tie(0),cout.tie(0)

# 二分查找
```c++
int binarySearch(vector<int> &nums, int target) {
  int left = 0, right = nums.size() - 1; // 定义 target 在左闭右闭的区间里，[left, right]
  while (left <= right) { // 当 left==right，区间 [left, right] 依然有效，所以用 <=
    int mid = left + (right - left) / 2); // 防止溢出，结果等同于(left + right)/2
    if (nums[mid] > target) {
      right = mid - 1; // target 在左区间，所以更新为 [left, mid - 1]
    } else if (nums[mid] < target) {
      left = mid + 1; // target 在右区间，所以更新为 [mid + 1, right]
    } else {
      // nums[mid] == target
      return mid; // 数组中找到目标值，直接返回下标
    }
  }
  // 未找到目标值
  return -1;
}

```
## stl中提供的简单的二分数字查找
```c++
vector<int> nums = {10, 20, 30, 30, 40, 50, 60};
auto it = lower_bound(nums.begin(), nums.end(), 30);
int index = it - nums.begin();//注意,因为返回的是迭代器,是地址,我们要求得下标的话就要减去最开始的地址
cout << "Lower bound of 30 is at index: " << index << ", value: " << *it <<endl;
/*返回下标2--value为30*/
auto it = upper_bound(nums.begin(), nums.end(), 30);
int index = it - nums.begin();
cout << "Upper bound of 30 is at index: " << index << ", value: " << *it <<endl;
/*返回下标*/
```
# 求一个数的二进制长度
```c++
int hightbit(int x){
	if(!x)return ERROR;
	for(int j = 30;~j;j--){
		if(x&(1<<j))return j;//获取第一个为1的数
	}
}
```

# 滑动窗口
```c++
void slidingWindow(string s, string t){
    unordered_map<char, int> need, window;
    for(char c : s)
        need[c]++;
    int left = 0, right = 0;
    // 窗口中的合法字符数
    int valid = 0;
    // 左开右闭区间
    while(right < s.size()){
        // c是将要移入窗口的字符
        char c = s[right];
        // 右移窗口
        right++;
        // 进行窗口内数据的一系列操作更新
        ...
            
        // 判断左侧窗口是否需要收缩
        while(window need shrink){
            // d是将要移除窗口的字符
            char d = s[left];
            // 左移窗口
            left++;
            // 进行窗口内数据的一系列操作更新
            ...
        }
    }
}
```
核心思路就是右指右移,根据当前窗口状态来判断左边窗口是否需要收缩,维护这样一个窗口

# 离散化
```c++
for (int i = 1; i <= n; ++i) // step 1 获取原数组的副本
	tmp[i] = arr[i];
std::sort(tmp + 1, tmp + n + 1); // step 2 将原数组进行排序
int len = std::unique(tmp + 1, tmp + n + 1) - (tmp + 1); // step 3 去重 
for (int i = 1; i <= n; ++i) // step 4 
	arr[i] = std::lower_bound(tmp + 1, tmp + len + 1, arr[i]) - tmp;
	//获取原数组的每一个元素在副本中的位置
```
```c++
std::vector<int> tmp(arr); // tmp 是 arr 的一个副本 
std::sort(tmp.begin(), tmp.end()); 
tmp.erase(std::unique(tmp.begin(), tmp.end()), tmp.end());//去除unique后的重复的元素,因为unique会将重复的元素放到后面
for (int i = 0; i < n; ++i) 
	arr[i] = std::lower_bound(tmp.begin(), tmp.end(), arr[i]) - tmp.begin();
```