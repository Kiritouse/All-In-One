> 个人感觉 CCF CSP第二题很喜欢考前缀和和差分


适合对区间进行处理
序列$a_1$, $a_2$, $a_3$, $a_4$, $a_5$,......$a_n$
# 前缀和: 
prefix[0] = 0;
prefix[1] = $a_1$;
prefix[2] = $a_1$+$a_2$;
prefix[3] = $a_1$+$a_2$+$a_3$;
..
==预处理:==
```c++
for(int i = 1;i<=n;i++){
	prefix[i] = prefix[i-1]+ a[1];
}
```
==还原原始数组==:$a_i$ = prefix[i]-prefix[i-1];
区间和


# 差分:
>差分是一种数据处理方式
>有些题目并没有明显的差分的形式
>但是在我们构造某些数组的时候,可以用差分来快速对构造的数组的某一区间进行批量修改
>再通过对差分数组进行前缀和,即可还原
diff[0] = 0;
diff[1] = $a_1$
diff[2] = $a_2$-$a_1$;
diff[3] = $a_3$-$a_2$;
...

==预处理==
```c++
for(int i = 1;i<=n;i++){
	diff[i] = a[i]-a[i-1];
}
```

==还原==: $a_i$ = diff[i]+a[i-1] **这里也相当于一个前缀和**

- **差分适用于对一个区间加上或者减去某个数**
diff[l]+=x,diff[r+1]-=x; 这两步操作对于[l,r]加上了一个数字x;
我们diff[l]+=x等价于对于[l,n]+x
diff[r+1]等价于对于[r,n]-x
- **也适用于对一个区间进行某些特征的统计**
[AcWing 5267. 合格数(前缀和 + 差分 + 线段树) - AcWing](https://www.acwing.com/solution/content/205907/)
此题就利用差分来处理==一段区间==内每个点被覆盖了多少次
再==还原==出原始数组,得到==某个点==被覆盖了多少次



## 例题
[507. 积木大赛 - AcWing题库](https://www.acwing.com/problem/content/description/509/)

这道题我们首先要学会==转化问题==
题目是从0->目标高度,不如逆行思考,从目标高度->0

对目标高度构造差分数组
![](Pasted%20image%2020240826144427.png)
因此问题变成每次从 b1,b2,…,bn+1  注意这里多了一个bn+1,因此sum bi = 0
 中挑两个数，前一个减1，后一个加1，问最少操作多少次可以将所有数变成0


所有数为0代表bi的前缀和为0
并且bi为0

所有总的操作次数一定不能少于差分数组中的所有正数之和B

==这里就是贪心了==
贪心最难的就是证明是否有操作满足可以达到B




[AcWing 507. 积木大赛 - AcWing](https://www.acwing.com/solution/content/3256/)  还是查看题解好些